# Scala Case Classes

- One of the most powerful ways to use 'match' expressions
- Can be thought of as similar to OO extensions of the concept of enums
- Parameterized enums
- A form of value type
- Case classes are standard classes with a special modifier: case
- Constructor parameters become public 'fields'
- Methods toString(), equals() and hashCode() are defined based on the constructor fields
- case modifier signals the compiler to assume certain things about 
  the class and to define certain boilerplate based on those assumptions.
- Default case classes methods can be overridden

- case classes cannot be subclassed

*NOTE:* Setter and getter, toString, equals, hashCode can be generated by IDE.
However, in case of any change in class, those methods have to be regenerated.
But this is not an issue in case classes.

## Provided Conveniences

- It adds a factory method with the name of the class.(Person("Selim"))
- All argumnets in the parameter list of a case class implicitly get a val prefix.
- It add natural implementations of methods toString, hashCode, equals.
- It add a copy method for making modified copies.

```scala
case class TemperatureAlarm(temp : Double)

// creating case class object without new keyword
// like enum
// under the hood there is a factory method creating object
// apply method is being used when called without new
// TemperatureAlarm.apply(99.9)
val alarm = TemperatureAlarm(99.9)
```


```java
// equivalent java class
public class TemperatureAlarm {
  private final double temp;

  // (temp) constructor
  // getTemp()
  // toString()
  // hashCode()
  // equals(Object)
}
```


```java
case class Point(x : Int, y : Int) {
  def *(m: Int) = Point(this.x * m, this.y * m)
  def +(other: Point) = Point(this.x + other.y, this.y + other.y)
}
```
