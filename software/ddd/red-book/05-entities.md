# Entities

- An Entity is a unique thing and is capable of being changed continuously over
  a long period of time.

- It is the unique identity and mutability characteristics that set Entities
  apart from Value Objects.

## Unique Identity

- Rather than focusing on the attributes or even the behavior, strip the Entity
  object's definition down to the most intrinsic characteristics, particularly
  those that identify it or are commonly used to find or match it. Add only
  behavior that is essential to the concept and attributes that are required by
  that behavior.

- Value Objects can serve as holders of unique identity. They are immutable,
  which ensure identity stability, and any behavior specific to the kind of
  identity is centralized.

* Some common identity creation strategies:

1. The user provides one or more original unique values as input to the
   application. The application must ensure that they are unique.

2. The application internally generates an identity using an algorith that
   ensures uniqueness.

3. The application relies on a persistence store, such as a database, to
   generate a unique identity.

4. Another Bounded Context has already determined the unique identity. IT is
   input or selected by the user from a set of choices.

** User Provides Identity

- Should be unique, correct, and immutable (given wrong, no correction?)

- We always have the option to include user-entered values as Entity properties
  available for matching, but not to use them for unique identity.

** Application Generates Identity

- UUID, GUID

1. Time in milliseconds on the computing node
2. IP address of the computing code
3. Object identity of the factory object instance within the VM
4. Random number generated by the same generator within the VM


```java
public class ProductRepository {
  
  public ProductId nextIdentity() {
    return new ProductId(UUID.randomUUID().toString().toUpperCase());
  }
}
```

** Persistence Mechanism Generates Identity

- One possible downside is performance, it can take significantly longer to go
  to the db to get each value than to generate identities in the application.

- One solution to the problem above could be using cache, that has its own disadvantages.

- Preallocation and caching are not an issue if the model can suffice with late
  identity generation.

* 'Early identity' generation and assignment happen 'before' the Entity is persisted
* 'Late identity' generation and assignment happen 'when' the Entity is persisted

- Here is a Repository supports early generation, serving the next available
  Oracle sequence using query.

```shell
public ProductId nextIdentity() {
   Long rawProductId = (Long)
     this.session().createSQLQuery(
     "select product_seq.nextval as product_id from dual")
     .addScalar("product_id", Hibernate.LONG)
     .uniqueResult();

  return new ProductId(rawProductId);
}
```

- Hibernate (does not) support early identity generation?

** Another Bounded Context Assign Identity

- Caching the object from another context locally.

- This is rarely easy to do, but it leads to more autonomous systems.

- This is the most complex of identity creation strategies.

## When the timing of identity generation matters

- If there is no interest in the identity of the Entity while/after creation,
  there is no problem.

- In some cases, the identity of Entity is required for other actions, and early
  identity generation is necessary.

- Collecting newly created Entities in a Set, and equality is based on identity?

- Other attributes could be used if identity is not set yet, but this should not
  be highly preferable. Entity equality should be on identity.

** Surrogate Identity

- Some ORM tools (Hibernate) want to deal with object identity on their own terms

- Hibernate prefers the database's native type, such as numeric seq

- If the domain requires another kind of identity, it causes conflicts

- To cure this, we need to identities, one is designed for the domain model and
  adheres to the requirements of the domain. The other is for Hibernate and is
  known as 'surrogate identity'

- It is best to hide the surrogate attribute from the outside world. Because the
  surrogate is not part of the doamin model, visibility constitutes persistence
  leakage.

- Surrogate database primary keys can be used throughtout the data model as
  foreign keys in other tables, providing referential integrity.

## Discovering Entities and Their Intrinsic Characteristics
