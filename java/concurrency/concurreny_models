- A concurrency model specifies how threads in the system collaborate 
  to complete the jobs they are given. Different models splits the jobs
  in different ways, and thread may communicate and collaborate in differeny ways.

- There are similarities between concurrency models and distributed system.
  In one of them threads are main player, in the other processes on different systems.
  
- Cus of similarities in their nature, they borrow ideas from each other. 
  Models of distributing work among works is often similar to models of load balancing in dis. sys.

## Parallel Workers Modelo

           |- Worker
Delegator --- Worker 
           |- Worker

If the parallel worker model was implemented in a car factory, each car would be
produced by one worker. The worker would get the specification of the car to build,
and would build everything from start to end.

!! Utilities in java.util.concurrent are designed for use with this model.

### Advantages
- Easir to understand
- Add more workers to increase parallelization of the application
- web crawler, IO instensive add more worker to keep CPU busy

### Disadvantages
- Shared resources is a big problems. Need to be sure data retrieve is fresh.
- If threads wait for accessing shared resources, some of the parallelization would be lost.
- Above problem could be solved with non-blocking algorithms, but they are hard to implement.
- Linked list are not a good way to store data, as they are spread on the computer memory
  a list implemented using array is much better for current CPU, as array is sequential data.
- If a worker is stateless, and doesnt keep state internally but re-reading data every time can make it slow.
- Job ordering is nondeterministic. Even a job given before another one, doesnt mean it is executed first.
  It makes it hard to reason about the state of the system at any given point in time.

